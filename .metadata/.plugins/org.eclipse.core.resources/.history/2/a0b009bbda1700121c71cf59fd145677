/* $Id:$ 
 * Creation : October 11, 2010
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            29004544
 */
package ecore;

require kermeta
require "ecore_behavior.kmt"
require "EcoreGenericsHelper.kmt"
require "EcoreUtil.kmt"

using ecore
using kermeta::standard
using kermeta::io
using EcoreUtil

class EcoreDocHelper2
{
	/**
	 * opération : flat
	 * affiche la hiérachie d'héritage d'une classe
	 * @param 	EClass 	e 	la classe dont on veut obtenir la hiérarchie d'héritage
	 * @param 	EString	s 	une chaine de caractère représentant le niveau d'indentation
	 *
	 * @return 	EString 	la chaine de caractère correspondant à l'opération flat sur la classe	
	 */
	operation flat(classEntree : EClass, sEntree : EString) : EString
	is do
		// on mémorise le nom de la classe dans la chaine de sortie
		var sSortie : EString
		sSortie := sEntree + classEntree.name + " : "

		// on applique l'opération flat pour l'ensemble des supertypes de la classe
		classEntree.eSuperTypes.each { parentClass | do 
			sSortie := sSortie + "\n" + flat(parentClass, sEntree + "  ")
		end }
		
		// on retourne le résultat
		result := sSortie
	end
	
	/**
	 * opération : short
	 * décrit les attributs et opérations d'une classe
	 * @param 	EClass 	e 	la classe dont on veut obtenir les attributs et opérations
	 * @param 	EString	s 	une chaine de caractère représentant le niveau d'indentation
	 *
	 * @return 	EString 	la chaine de caractère correspondant à l'opération short sur la classe	
	 */
	operation short(classEntree : EClass, sEntree : EString) : EString
	is do
		var sSortie : EString init ""
		
		// affichage des attributs
		classEntree.eAttributes.each{ attributCourant |
		do
			sSortie := sSortie + "\n" + sEntree + "attr " + attributCourant.name + " : " + attributCourant.eAttributeType.name
		end
		}
		
		// affichage des références
		classEntree.eReferences.each{ referenceCourante |
		do
			// affichage du type de la référénce
			sSortie := sSortie + "\n" + sEntree + "ref " + referenceCourante.name + " : " + referenceCourante.eReferenceType.name
			
			// affichage des cardinalités (avec gestion du cas particulier des cardinalités -1)
			var upperBound : EString init ""
			if (referenceCourante.upperBound == -1)
			then
				upperBound := "*"
			else
				upperBound := referenceCourante.upperBound.toString
			end
			sSortie := sSortie + "[" + referenceCourante.lowerBound.toString + ".." + upperBound + "]"
		end
		}
		
		// affichages des opérations de la classe
		classEntree.eOperations.each{ operationCourante |
		do
			// affichage du nom de l'opération
			sSortie := sSortie + "\n" + sEntree + "op " + operationCourante.name
			
			// affichage des paramètres de l'opération
			var bPremiereIteration : Boolean init true
			sSortie := sSortie + "("
			operationCourante.eParameters.each{ parametreCourant | 
			do
				// dans le cas de la première itération, on n'affiche pas la virgule
				if (bPremiereIteration)
				then
					bPremiereIteration := false
				else
					sSortie := sSortie + ", "
				end
				// le parametre et le type
				sSortie := sSortie + parametreCourant.name + " : " + parametreCourant.eType.name
			end
			}
			sSortie := sSortie + ")"
			
			// le type de retour
			if (operationCourante.eType != void)
			then
				sSortie := sSortie + " : " + operationCourante.eType.name
			else
				sSortie := sSortie + " : Void"
			end
			
		end
		}
		
		// renvoie de la chaine de caractère de l'opération short
		result := sSortie
	end
	
	/**
	 * opération : flatshort
	 * idem à l'opération short en incluant les membres hérités des superclasses
	 * @param 	EClass 	e 	la classe dont on veut obtenir les attributs et opérations (dont les hérités)
	 * @param 	EString	s 	une chaine de caractère représentant le niveau d'indentation
	 *
	 * @return 	EString 	la chaine de caractère correspondant à l'opération flatshort sur la classe	
	 */
	operation flatshort(classEntree : EClass, sEntree : EString) : EString
	is do
		// on mémorise le nom de la classe dans la chaine de sortie
		var sSortie : EString
		sSortie := sEntree + classEntree.name + " : "
		
		// on mémorise l'operation short de la classe dans la chaine de sortie
		sSortie := sSortie + short(classEntree, sEntree + "  ")
		
		// on applique l'opération flatshort pour l'ensemble des supertypes de la classe
		classEntree.eSuperTypes.each { parentClass | do 
			sSortie := sSortie + "\n" + flatshort(parentClass, sEntree + "  ")
		end }
		
		// renvoie de la chaine de caractère de l'opération flatshort
		result := sSortie
	end
		
	/**
	 * opération : addDataType
	 * Permet d'ajouter un datatype à un package
	 * @param 	EString 	nom 			le nom du datatype
	 * @param 	EString		instanceClass 	la classe instanciable du datatype
	 * @param	EPackage 	unPackage		le package où l'on souhaite ajouter le datatype
	 *
	 * @return 	EDataType 	le nouveau EDataType créé
	 */
	operation addDataType(nom : EString, instanceClass : EString, unPackage : EPackage) : EDataType
	is do
		// création du datatype
		var dataType : EDataType init EDataType.new
		dataType.name := nom
		dataType.instanceClassName := instanceClass
		
		// ajout du datatype au package
		unPackage.eClassifiers.add(dataType)
		
		// on retourne le datatype créé
		result := dataType
	end
	
	/**
	 * opération : addAttribute
	 * Permet d'ajouter un attribut à une classe
	 * @param 	EString			nom 			une chaine de caractère représentant le niveau d'indentation
	 * @param	EClassifier 	type			le type de l'attribut
	 * @param 	EClass 			classEntree 	la classe où l'on souhaite ajouter un attribut
	 *
	 * @return 	EAttribute 		l'attribut créé
	 */
	operation addAttribute(nom : EString, type : EClassifier, classEntree : EClass) : EAttribute
	is do		
		// création de l'objet attribut
		var unAttribut : EAttribute init EAttribute.new
		unAttribut.name := nom
		unAttribut.setType(type)
		
		// ajout de l'attribut dans la classe
		classEntree.eStructuralFeatures.add(unAttribut)
		
		// on retourne l'attribut
		result := unAttribut
	end
	
	/**
	 * opération : addOperation
	 * Ajout d'une opération sur une classe
	 * @param 	EString 			nom 			le nom de l'opération
	 * @param 	EClassifier		typeRetour 		le type de retour de l'opération
	 * @param	EClass 			uneClasse		la classe sur laquelle l'opération va être ajoutée
	 *
	 * @return 	EOperation 		la nouvelle opération créée
	 */
	operation addOperation(nomOp : EString, typeRetour : EClassifier, uneClasse : EClass) : EOperation
	is do
		// création de l'opération
		var uneOperation : EOperation init EOperation.new
		uneOperation.name := nomOp
		// ajout du type de l'opération si celui-ci n'est pas vide
		if ( typeRetour != void )
		then
			uneOperation.setType(typeRetour)
		end
		
		// ajout de l'opération dans la classe
		uneClasse.eOperations.add(uneOperation)
		
		// on retourne l'opération
		result := uneOperation
	end
	
	/**
	 * opération : addParameter
	 * Ajout d'un paramètre sur une opération
	 * @param 	EString 		nom 			le nom du paramètre
	 * @param 	EClassifier		type 			le type du paramètre
	 * @param	EOperation 		uneOperation	l'opération sur laquelle le paramètre va être ajouté
	 *
	 * @return 	EParameter 		le paramètre créé
	 */
	operation addParameter(nom : EString, type : EClassifier, uneOperation : EOperation) : EParameter
	is do
		// création du paramètre
		var unParam : EParameter init EParameter.new
		unParam.name := nom
		unParam.setType(type)
		
		// ajout du paramètre à l'opération
		uneOperation.eParameters.add(unParam)
		
		// on retourne le paramètre
		result := unParam
	end
	
	/**
	 * opération : creerClass
	 * Création d'une nouvelle classe
	 * @param 	EString nom 	le nom de la classe
	 *
	 * @return 	EClass 	la classe créée
	 */
	operation creerClass(nom : EString) : EClass
	is do
		// création d'une nouvelle classe
		var uneClass : EClass init EClass.new
		uneClass.name := nom
		
		// on retourne la classe
		result := uneClass
	end
	
	/**
	 * opération : creerPackage
	 * Création d'un nouveau package
	 * @param 	EString 	nom 	le nom du package
	 * @param 	EPackage 	parent	le package où l'on souhaite ajouter un package
	 *
	 * @return 	EPackage 	le nouveau package créé
	 */
	operation creerPackage(nom : EString, parent : EPackage) : EPackage
	is do
		// création du nouveau package
		var enfant : EPackage init EPackage.new
		enfant.name := nom
		
		// ajout du package à son parent
		parent.eSubpackages.add(enfant)
		
		// on retourne le package
		result := enfant
	end
	
	/**
	 * opération : addVisitorPattern
	 * Application du pattern visitor sur un package specifique
	 * @param 	EPackage 	unPackage	le package où l'on souhaite appliquer le pattern
	 */
	operation addVisitorPattern(unPackage : EPackage)
	is do
		// initialisation de l'helper
		var helpers : EcoreUtil init EcoreUtil.new
		
		// -------------------------------- //
		// Mise en place du package Visitor //
		// -------------------------------- //
		// création d'un package Visitor
		var visitorPackage : EPackage init creerPackage("visitor", unPackage)
		
		// création de l'interface Visitable (ajout au package visitor)
		var interfaceVisitable : EClass init creerClass("Visitable")
		interfaceVisitable.interface := true
		visitorPackage.eClassifiers.add(interfaceVisitable)
		
		// création de la classe Abstraite Visitor (ajout au package visitor)
		var abstractVisitor : EClass init creerClass("Visitor")
		abstractVisitor.~abstract := true
		visitorPackage.eClassifiers.add(abstractVisitor)
		
		// creation d'un visiteur concret MyVisitor (ajout au package visitor)
		var visitorConcret : EClass init creerClass("MyVisitor")
		visitorConcret.addSuperType(abstractVisitor)
		visitorPackage.eClassifiers.add(visitorConcret)
		
		// ajout de l'opération accept (dans l'interface Visitable)
		var operationAccept : EOperation init addOperation("accept", void, interfaceVisitable)
		addParameter("v", abstractVisitor, operationAccept)
		
		// ajout de l'opération visit (dans la classe abstraite Visitor)
		var operationVisit : EOperation init addOperation("visit", void, abstractVisitor)
		addParameter("v", interfaceVisitable, operationVisit)

		// -------------------------------------------- //
		// Application du pattern visitor sur le modèle //
		// -------------------------------------------- //
		// ajout du pattern Visitor sur les classes du modèle
		unPackage.eClassifiers.each{e |
		do
			var classCourante : EClass
			classCourante ?= e
			if (classCourante != void)
			then
				// implémentation de l'interface
				classCourante.addSuperType(interfaceVisitable)
				
				// ajout de l'opération
				var operationAcceptConcrete : EOperation init addOperation("accept", void, classCourante)
				addParameter("v", abstractVisitor, operationAcceptConcrete)
				helpers.addAnnotation(operationAcceptConcrete, "", "kermeta", "v.visit" + classCourante.name + "(self)")
				
				// ajout de l'operation visit<Name> dans la visitor abstrait
				var operationVisitor : EOperation init addOperation("visit" + classCourante.name, void, abstractVisitor)
				addParameter("v", interfaceVisitable, operationVisitor)
			end
		end
		}
	end
	
	/**
	 * operation : generate_visitor
	 * Generation du fichier tableur_visitors.kmt
	 * @param 	EPackage 	modele 	le modèle sur lequel on se base pour générer le pattern visitor
	 */
	operation generate_visitor(modele : EPackage) : Void
	is do
		// mise en place d'un buffer
		var buffer : String init ""
		
		// generation de l'entête du fichier
		buffer.append("package spreadsheet::visitors;\n\n")
		buffer.append("require \"tableur.kmt\"\n")
		buffer.append("require kermeta\n\n")
		buffer.append("using spreadsheet\n\n")
		
		// génération de la classe abstraite Visitor
		buffer.append("abstract class Visitor {\n")
		modele.eClassifiers.each{e |
		do
			var classCourante : EClass
			classCourante ?= e
			if (classCourante != void)
			then
				buffer.append("		operation visit" + classCourante.name + "(v : " + classCourante.name + ") : Void is abstract\n")
			end
		end
		}
		buffer.append("}\n\n")
		
		// génération de l'interface Visitable
		buffer.append("class Visitable {\n")
		buffer.append("		operation accept(v : Visitor) : Void is abstract\n")
		buffer.append("}\n\n")
		
		// generération du visitor concrete
		buffer.append("class MyVisitor inherits Visitor {\n")
		modele.eClassifiers.each{e |
		do
			var classCourante : EClass
			classCourante ?= e
			if (classCourante != void)
			then
				buffer.append("		method visit" + classCourante.name + "(v : " + classCourante.name + ") : Void from Visitor\n")
				buffer.append("		is do\n\n")
				buffer.append("		end\n\n")
			end
		end
		}
		buffer.append("}\n\n")
		
		// création du fichier Tableur_visitor.kmt
		var hFile : FileIO init FileIO.new
		hFile.writeTextFile("tableur_visitors.kmt" , buffer)
	end
	
	/**
	 * operation : generate_aspects
	 * Generation du fichier tableur.kmt
	 * @param 	EPackage 	modele 	le modèle sur lequel on se base pour générer le pattern visitor
	 */
	operation generate_aspects(modele : EPackage) : Void
	is do
		// mise en place d'un buffer
		var buffer : String init ""
		
		// generation de l'entête du fichier
		buffer.append("package spreadsheet;\n\n")
		buffer.append("require \"../../model/tableur_modified.ecore\"\n")
		buffer.append("require \"tableur_visitors.kmt\"\n")
		buffer.append("require kermeta\n\n")
		buffer.append("using spreadsheet::visitors\n\n")
		
		// génération des aspects
		modele.eClassifiers.each{e |
		do
			var classCourante : EClass
			classCourante ?= e
			if (classCourante != void)
			then
				buffer.append("aspect class " + classCourante.name + " inherits Visitable {\n")
				buffer.append("		method accept(v : Visitor) from Visitable\n")
				buffer.append("		is do\n")
				buffer.append("			v.visit" + classCourante.name + "(self)\n")
				buffer.append("		end\n")
				buffer.append("}\n\n")
			end
		end
		}
		
		// création du fichier Tableur.kmt
		var hFile : FileIO init FileIO.new
		hFile.writeTextFile("tableur.kmt" , buffer)
	end
}